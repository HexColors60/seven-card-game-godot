extends Node

const port = 3560

var server # for holding your TCP_Server object
var connection # for holding multiple connection (StreamPeerTCP) objects
var peerstream # for holding multiple data transfer (PacketPeerStream) objects

var is_server_leading # is server leading the game
var did_server_win
# Signals generated by server
signal card_was_played
signal carry_pressed
signal take_pressed
signal take_or_card
signal carry_or_card
#-------------------------------
# Variables for nodes
var pile
var serverHand
var clientHand
var deck
var timer
var serverGrave
var clientGrave
var takeButton
var carryButton
var leadIndicatorServer
var leadIndicatorClient
var player
var turnStatus
#-------------------------------------
# Bools for registering events
var cardPlayed = false
var takePressed = false
var carryPressed = false
#--------------------------------------------------
# Initializing the server
func init_server(v_server, v_connection, server_win = true):
	server = v_server
	connection = v_connection
	peerstream = PacketPeerStream.new()
	peerstream.set_stream_peer(connection)
	did_server_win = server_win
	is_server_leading = server_win

func connection_check():
	if connection.is_connected() == false:
		get_tree().get_root().get_node("Scene").reset_menu()
		get_tree().get_root().get_node("Scene/Menu").get_node("StatusLabel").set_text("Connection lost.")
		get_tree().get_root().get_node("Scene/Menu").get_node("StatusLabel").show()
		get_tree().get_root().get_node("Scene/Menu").show()
		queue_free()

func _ready():
	# putting nodes into variables for better access
	pile = get_node("Pile")
	serverHand = get_node("Hand")
	clientHand = get_node("Hand 2")
	deck = get_node("Deck")
	timer = get_node("Timer")
	serverGrave = get_node("Graveyard")
	clientGrave = get_node("Graveyard 2")
	takeButton = get_node("Take")
	carryButton = get_node("Carry")
	leadIndicatorServer = get_node("LeadIndicator")
	leadIndicatorClient = get_node("LeadIndicator1")
	player = get_node("SamplePlayer")
	turnStatus = get_node("TurnStatus")
	#-------------------------------------------------------
	
	carryButton.connect("pressed", self, "carry_button_pressed")
	takeButton.connect("pressed", self, "take_button_pressed")
	carryButton.set_disabled(true)
	takeButton.set_disabled(true)
	update_lead_indicator()
	# Make a deck and deal the cards
	var karte = []
	for i in range(0,4):
		serverHand.add_to_hand(deck.draw())
		var c = deck.draw()
		clientHand.add_to_hand(c)
		karte.append(c.rank)
		karte.append(c.suit)
	serverHand.turn_over()
	peerstream.put_var(["start", karte[0], karte[1], karte[2], karte[3], karte[4], karte[5], karte[6], karte[7]])
	#--------------------------------------------------------
	game_loop() # Loop in which the game is played

func game_loop():
	while !deck.is_empty() or !serverHand.is_empty() or !clientHand.is_empty() or !pile.is_empty():
		if did_server_win:
			# SERVER PLAYS
			turnStatus.set_text("Your turn.")
			if pile.is_empty(): # if pile is empty throw a card
				print("Pile je empty.")
				serverHand.connect("card_played", self, "play_card")
				while true:
					connection_check()
					if cardPlayed:
						break
					else:
						timer.start()
						yield(timer, "timeout")
				cardPlayed = false
				print("Bacio sam kartu.")
				serverHand.disconnect("card_played", self, "play_card")
			else: # if not
				print("Pile nije empty")
				if pile.can_carry(): # if number of cards on pile is even
					print("paran broj")
					if is_server_leading: # if me (server) is leading
						print("Server vodi.")
						# Take cards from pile or continue with another card
						takeButton.set_disabled(false)
						serverHand.connect("card_played", self, "play_card")
						print("Cekam da se baci karta ili pritisne Take.")
						while true:
							connection_check()
							if cardPlayed or takePressed:
								break
							else:
								timer.start()
								yield(timer, "timeout")
								
						cardPlayed = false
						#---------------------------------
						# If we took the cards from the pile, begin the next round
						if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
							break
						if takePressed:
							print("Take je bio pritisnut. Cekam da se baci karta.")
							while true:
								connection_check()
								if cardPlayed:
									break
								else:
									timer.start()
									yield(timer, "timeout")
									
							cardPlayed = false
							print("Karta bacena.")
						takePressed = false
						takeButton.set_disabled(true)
						serverHand.disconnect("card_played", self, "play_card")
						#--------------------------------------------
					else: # if he (client) is leading tell him to take the cards or continue
						print("Klijent vodi.")
						carryButton.set_disabled(false)
						serverHand.connect("card_played", self, "play_card")
						print("Cekam da se igra karta ili pritisne Give.")
						while true:
							connection_check()
							if cardPlayed or carryPressed:
								break
							else:
								timer.start()
								yield(timer, "timeout")
						if carryPressed: # If we pressed Take
							pile_to_graveyard(clientGrave) # Putting cards on client grave
							print("Give pritisnut")
						carryButton.set_disabled(true)
						cardPlayed = false
						carryPressed = false
						serverHand.disconnect("card_played", self, "play_card")
				else: # If the number of cards on pile is odd, play a card
					print("Neparan broj")
					serverHand.connect("card_played", self, "play_card")
					print("Cekam da se odigra karta")
					while true:
						connection_check()
						if cardPlayed:
							break;
						else:
							timer.start()
							yield(timer, "timeout")
					print("Karta odigrana")
					cardPlayed = false
					serverHand.disconnect("card_played", self, "play_card")
		did_server_win = true
		if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
			break
		# CLIENT PLAYS
		var packet
		print("Igra klijent")
		turnStatus.set_text("Waiting for opponent...")
		print("Cekam paket")
		while true:
			connection_check()
			if peerstream.get_available_packet_count() > 0:
				packet = peerstream.get_var()
				if packet[0] == "throw" or packet[0] == "carry_pressed" or packet[0] == "take_pressed":
					break;
			else:
				timer.start()
				yield(timer, "timeout")
		print("Paket primljen")
		if packet[0] == "throw":
			print("Klijent baca kartu")
			var card = clientHand.is_in_hand(packet[1], packet[2])
			if card != null:
				client_play_card(card)
		elif packet[0] == "carry_pressed":
			print("Klijent pritisnuo Give")
			var n_draw
			if deck.cards_remaining() >= pile.cards_on_pile.size():
				n_draw = pile.cards_on_pile.size()/2
			else:
				n_draw = deck.cards_remaining()/2
			pile_to_graveyard(serverGrave)
			var karte = []
			var packet = ["confirm", n_draw]
			for i in range(0,n_draw):
				var c = deck.draw()
				if c != null:
					serverHand.add_to_hand(c)
				c = deck.draw()
				if c != null:
					clientHand.add_to_hand(c)
					karte.append(c.rank)
					karte.append(c.suit)
			serverHand.turn_over()
			for x in karte:
				packet.append(x)
			peerstream.put_var(packet)
			if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
				break
		elif packet[0] == "take_pressed":
			print("Klijent pritisnuo Take")
			var n_draw
			if deck.cards_remaining() >= pile.cards_on_pile.size():
				n_draw = pile.cards_on_pile.size()/2
			else:
				n_draw = deck.cards_remaining()/2
			pile_to_graveyard(clientGrave)
			if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
				break
			var karte = []
			var packet = ["confirm", n_draw]
			for i in range(0,n_draw):
				var c = deck.draw()
				if c != null:
					serverHand.add_to_hand(c)
				c = deck.draw()
				if c != null:
					clientHand.add_to_hand(c)
					karte.append(c.rank)
					karte.append(c.suit)
			serverHand.turn_over()
			for x in karte:
				packet.append(x)
			peerstream.put_var(packet)
			if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
				break
			while true:
				connection_check()
				if peerstream.get_available_packet_count() > 0:
					packet = peerstream.get_var()
					if packet[0] == "throw":
						break;
				else:
					timer.start()
					yield(timer, "timeout")
			var card = clientHand.is_in_hand(packet[1], packet[2])
			if card != null:
				client_play_card(card)
			if deck.is_empty() and serverHand.is_empty() and clientHand.is_empty() and pile.is_empty():
				break
	# GAME OVER, PROCESSING AND RESULTS
	var clientPoints = clientGrave.get_points()
	var serverPoints = serverGrave.get_points()
	peerstream.put_var(["result", serverPoints, clientPoints])
	var new_scene = load("res://Result.tscn").instance()
	new_scene.init_results(serverPoints, clientPoints, is_server_leading, true, server, connection)
	get_tree().get_root().get_node("Scene").add_child(new_scene)
	queue_free()

func update_lead_indicator():
	if is_server_leading:
		leadIndicatorServer.show()
		leadIndicatorClient.hide()
	else:
		leadIndicatorServer.hide()
		leadIndicatorClient.show()

func play_card(card):
	if pile.is_empty() or (pile.can_carry() and (card.rank == pile.get_lead_card()  or card.rank == 7)) or !pile.can_carry():
		if card.rank == pile.get_lead_card() or card.rank == 7:
			is_server_leading = true
		update_lead_indicator()
		serverHand.remove_card(card)
		pile.throw_to_pile(card)
		peerstream.put_var(["server", "throw", card.rank, card.suit])
		cardPlayed = true
		

func client_play_card(card):
	if pile.is_empty() or (pile.can_carry() and (card.rank == pile.get_lead_card()  or card.rank == 7)) or !pile.can_carry():
		if card.rank == pile.get_lead_card() or card.rank == 7:
			is_server_leading = false
		update_lead_indicator()
		clientHand.remove_card(card)
		pile.throw_to_pile(card)

func carry_button_pressed():
	var n_draw
	if deck.cards_remaining() >= pile.cards_on_pile.size():
		n_draw = pile.cards_on_pile.size()/2
	else:
		n_draw = deck.cards_remaining()/2
	var karte = []
	var packet = ["server", "carry_pressed", n_draw]
	for i in range(0,n_draw):
		var c = deck.draw()
		if c != null:
			serverHand.add_to_hand(c)
		c = deck.draw()
		if c != null:
			clientHand.add_to_hand(c)
			karte.append(c.rank)
			karte.append(c.suit)
	serverHand.turn_over()
	for x in karte:
		packet.append(x)
	peerstream.put_var(packet)
	carryButton.set_disabled(true)
	carryPressed = true

func take_button_pressed():
	var n_draw
	if deck.cards_remaining() >= pile.cards_on_pile.size():
		n_draw = pile.cards_on_pile.size()/2
	else:
		n_draw = deck.cards_remaining()/2
	pile_to_graveyard(serverGrave)
	var karte = []
	var packet = ["server", "take_pressed", n_draw]
	for i in range(0,n_draw):
		if !deck.is_empty():
			var c = deck.draw()
			if c != null:
				serverHand.add_to_hand(c)
			c = deck.draw()
			if c != null:
				clientHand.add_to_hand(c)
				karte.append(c.rank)
				karte.append(c.suit)
	serverHand.turn_over()
	for x in karte:
		packet.append(x)
	peerstream.put_var(packet)
	takeButton.set_disabled(true)
	takePressed = true

func pile_to_graveyard(grave):
	player.play("cardShove3", true)
	for card in pile.cards_on_pile:
		grave.add(card)
	pile.clean()